# -*- coding: utf-8 -*-
"""Design_the_Heap_DS.ipynb_part1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t5-1chLNa90tEXip-eXNIaPwY5abmh33

`Name:` `Tchangmena A Nken Allassan`

`Date:` `19-10-2022`

`Hello! here we will design the heap data structure, and all its properties we will start by building:`
1. The heap ✅
2. Implement the heapify function ✅
3. The heapsort 
4. extract the maximu from the heap
5. Insert an element in the heap
6. modify the value from the heap
7. Priority queue
"""

'''
Building the heap data structure (the class associated to it) 

lets use this array [3,4,5,6,2,0,1] which yield this heap
       3
      / \
    4    5      
   / \  / \
  6   2 0  1

'''
class heap:

  def __init__(self, array):
   ## we define heaps from arrays 
   ## so far we insert only the array here
   ## Remember here we're are building a max_heap
    self.array=array
    self.N =len(array)

  #### max heapify function
  def max_heapify(self,idx):
    ## building a max_heapify function

    ## Time complexity O(log(n))
    largest=idx
    left = 2*idx+1
    right=2*idx+2

    if left<self.N and self.array[left]>self.array[largest]:
      largest= left
    if right<self.N and self.array[right]>self.array[largest]:
      largest=right

    if largest!=idx:
      ### we swap the values in the array
      swap_idx,swap_largest= self.array[idx],self.array[largest]

      self.array[largest],self.array[idx]=swap_idx,swap_largest
      ##### then perform a recursion step
      self.max_heapify(largest)

  ### building a max_heap  
  def max_heap(self):
    ## we heapify the leaves N/2 to 1

    ## time complexity O(N)
    size=self.N//2
    for idy in range(size-1,-1,-1):
      
      self.max_heapify(idy)

  ### building the heapsort function

heap_ds=heap([3,4,5,6,2,0,1])
